<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Relations Visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        /* Theme variables */
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --primary-color: #2196f3;
            --primary-hover: #1976d2;
            --border-color: #cccccc;
            --section-bg: #f9f9f9;
            --section-border: #dddddd;
            --input-bg: #ffffff;
            --dropdown-bg: #ffffff;
            --dropdown-hover: #f5f5f5;
            --dropdown-selected: #e3f2fd;
            --controls-bg: rgba(255, 255, 255, 0.9);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --warning-color: #ff9800;
            --muted-color: #666666;
        }

        /* Dark theme */
        [data-theme="dark"] {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --primary-color: #64b5f6;
            --primary-hover: #42a5f5;
            --border-color: #404040;
            --section-bg: #2d2d2d;
            --section-border: #404040;
            --input-bg: #2d2d2d;
            --dropdown-bg: #2d2d2d;
            --dropdown-hover: #404040;
            --dropdown-selected: #1565c0;
            --controls-bg: rgba(45, 45, 45, 0.9);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --warning-color: #ffb74d;
            --muted-color: #a0a0a0;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 2em;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        h1 { color: var(--primary-color); }
        #visualization {
            border: 1px solid var(--border-color);
            margin-top: 2em;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 500px);
            min-height: 300px;
            background-color: var(--bg-color);
        }
        #network-container {
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: var(--controls-bg);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px var(--shadow-color);
            backdrop-filter: blur(10px);
        }
        #controls button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 5px;
            transition: background-color 0.2s ease;
        }
        #controls button:hover {
            background: var(--primary-hover);
        }
        .section {
            margin-bottom: 2em;
        }
        .label {
            font-weight: bold;
            color: var(--text-color);
        }

        /* Selection container for responsive layout */
        .selection-container {
            display: flex;
            flex-direction: column;
            gap: 1.5em;
            margin-bottom: 2em;
        }

        @media (min-width: 1024px) {
            .selection-container {
                flex-direction: row;
                gap: 2em;
                align-items: flex-start;
            }

            .selection-item {
                flex: 1;
                min-width: 0; /* Allow flex items to shrink below their content size */
            }
        }

        .selection-item .label {
            display: block;
            margin-bottom: 0.5em;
        }

        /* Searchable dropdown styles */
        .searchable-dropdown {
            position: relative;
            min-width: 250px;
            width: 100%;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s ease, background-color 0.3s ease;
        }

        .search-input:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--dropdown-bg);
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-color);
            transition: background-color 0.2s ease;
        }

        .dropdown-item:hover {
            background-color: var(--dropdown-hover);
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item.selected {
            background-color: var(--dropdown-selected);
            color: white;
        }

        .no-results {
            padding: 8px 12px;
            color: var(--muted-color);
            font-style: italic;
        }

        /* Legend styles */
        .legend {
            background: var(--section-bg);
            border: 1px solid var(--section-border);
            border-radius: 4px;
            padding: 15px;
            margin-top: 1em;
            font-size: 12px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-color);
        }
        .legend-section {
            margin-bottom: 10px;
        }
        .legend-section:last-child {
            margin-bottom: 0;
        }
        .legend-section-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--text-color);
        }
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-color);
        }
        .legend-shape {
            width: 16px;
            height: 16px;
            border: 2px solid;
            display: inline-block;
            text-align: center;
            line-height: 12px;
            font-size: 10px;
            font-weight: bold;
        }
        .legend-shape.ellipse {
            border-radius: 50%;
        }
        .legend-shape.box {
            border-radius: 2px;
        }
        .legend-shape.diamond {
            transform: rotate(45deg);
            border-radius: 2px;
        }

        /* Input styles */
        input[type="number"] {
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.2s ease;
        }

        input[type="number"]:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        /* Warning and info text */
        #depth-warning {
            color: var(--warning-color) !important;
        }

        .section div {
            color: var(--muted-color);
        }

        /* No selection message */
        #no-selection-message {
            color: var(--muted-color);
        }
    </style>
</head>
<body>
    <h1>Advanced Relations Visualization</h1>
    <div class="selection-container">
        <div class="selection-item">
            <span class="label">Entities:</span>
            <div class="searchable-dropdown" id="entities-dropdown">
                <input type="text" class="search-input" placeholder="Search entities..." data-type="entities">
                <div class="dropdown-list"></div>
            </div>
        </div>
        <div class="selection-item">
            <span class="label">Automations:</span>
            <div class="searchable-dropdown" id="automations-dropdown">
                <input type="text" class="search-input" placeholder="Search automations..." data-type="automations">
                <div class="dropdown-list"></div>
            </div>
        </div>
        <div class="selection-item">
            <span class="label">Scripts:</span>
            <div class="searchable-dropdown" id="scripts-dropdown">
                <input type="text" class="search-input" placeholder="Search scripts..." data-type="scripts">
                <div class="dropdown-list"></div>
            </div>
        </div>
    </div>
    <div class="section">
        <span class="label">Recursion Depth:</span><br>
        <div style="display: flex; gap: 2em; align-items: flex-start; margin-top: 0.5em;">
            <div style="flex-shrink: 0;">
                <input type="number" id="depth-input" value="3" min="0" step="1" style="padding: 8px 12px; border-radius: 4px; font-size: 14px; width: 100px;">
                <div style="font-size: 12px; margin-top: 4px; width: 250px; color: var(--muted-color);">
                    Enter depth (0 = infinite, higher values show more indirect relationships but may take longer).
                </div>
                <div id="depth-warning" style="font-size: 12px; margin-top: 4px; display: none; width: 250px;">
                    Warning: High depth values may significantly slow down the analysis.
                </div>
            </div>
            <div class="legend" style="flex: 1; margin-top: 0;">
                <div class="legend-title">Legend</div>
                <div class="legend-items" style="gap: 20px;">
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #e3f2fd; border-color: #2196f3;"></div>
                        <span>Entity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape box" style="background: #e8f5e8; border-color: #4caf50;"></div>
                        <span>Automation</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape diamond" style="background: #fff3e0; border-color: #ff9800;"></div>
                        <span>Script</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #fff59d; border-color: #ffc107;"></div>
                        <span>Selected</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #ffebee; border-color: #f44336;"></div>
                        <span>Trigger</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #f3e5f5; border-color: #9c27b0;"></div>
                        <span>Condition</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #e0f2f1; border-color: #009688;"></div>
                        <span>Output</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="visualization">
        <div id="controls">
            <button id="theme-toggle-btn">ðŸŒ™ Dark</button>
            <button id="download-btn">Download JSON</button>
            <button id="fit-btn">Fit View</button>
            <button id="reset-zoom-btn">Reset Zoom</button>
            <button id="layout-toggle-btn">Hierarchical Layout</button>
        </div>
        <div id="network-container"></div>
        <div id="no-selection-message" style="padding: 40px; text-align: center; font-size: 16px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted-color);">
            Select an entity, automation, or script above to view its relationships.
        </div>
    </div>
    <script>
    // Theme detection and management
    function detectAndApplyTheme() {
        // First, try to detect Home Assistant theme from parent window
        let theme = 'light'; // default

        try {
            // Check if we're in an iframe and can access parent
            if (window.parent && window.parent !== window) {
                // Try to get theme from Home Assistant's document
                const parentDoc = window.parent.document;
                const haElement = parentDoc.querySelector('home-assistant');

                if (haElement) {
                    // Check for hass object theme
                    if (window.parent.hass && window.parent.hass.themes) {
                        const selectedTheme = window.parent.hass.selectedTheme;
                        const themes = window.parent.hass.themes.themes;

                        if (selectedTheme && themes[selectedTheme]) {
                            // Check if it's a dark theme based on common indicators
                            const themeData = themes[selectedTheme];
                            if (themeData['primary-background-color']) {
                                const bgColor = themeData['primary-background-color'];
                                // Parse color to determine if it's dark
                                const isDark = isColorDark(bgColor);
                                theme = isDark ? 'dark' : 'light';
                            }
                        }
                    }

                    // Fallback: check for dark theme class on body or html
                    if (theme === 'light') {
                        const body = parentDoc.body;
                        const html = parentDoc.documentElement;
                        if (body.classList.contains('dark-theme') ||
                            html.classList.contains('dark-theme') ||
                            body.getAttribute('data-theme') === 'dark' ||
                            html.getAttribute('data-theme') === 'dark') {
                            theme = 'dark';
                        }
                    }
                }
            }
        } catch (e) {
            // If we can't access parent (CORS, etc.), fall back to system preference
            console.log('Cannot access parent window, using system preference');
        }

        // Fallback to system preference if we couldn't detect from HA
        if (theme === 'light' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            theme = 'dark';
        }

        // Apply theme
        applyTheme(theme);

        return theme;
    }

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);

        // Update theme toggle button
        const themeBtn = document.getElementById('theme-toggle-btn');
        if (themeBtn) {
            themeBtn.textContent = theme === 'dark' ? 'â˜€ï¸ Light' : 'ðŸŒ™ Dark';
        }

        // Update network colors if network exists
        if (network && networkData) {
            updateNetworkTheme(theme);
        }
    }

    function toggleTheme() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        applyTheme(newTheme);
    }

    function isColorDark(color) {
        // Convert color to RGB and calculate luminance
        let r, g, b;

        if (color.startsWith('#')) {
            // Hex color
            const hex = color.slice(1);
            r = parseInt(hex.substr(0, 2), 16);
            g = parseInt(hex.substr(2, 2), 16);
            b = parseInt(hex.substr(4, 2), 16);
        } else if (color.startsWith('rgb')) {
            // RGB color
            const matches = color.match(/\d+/g);
            if (matches && matches.length >= 3) {
                r = parseInt(matches[0]);
                g = parseInt(matches[1]);
                b = parseInt(matches[2]);
            } else {
                return false; // Default to light if can't parse
            }
        } else {
            return false; // Default to light for unknown formats
        }

        // Calculate relative luminance
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance < 0.5; // Dark if luminance is less than 50%
    }

    function updateNetworkTheme(theme) {
        if (!network || !networkData) return;

        // Update colors based on new theme
        colors = getColors();

        // Update network background based on theme
        const backgroundColor = theme === 'dark' ? '#1e1e1e' : '#ffffff';
        const fontColor = theme === 'dark' ? '#e0e0e0' : '#333333';

        // Update network container background
        const container = document.getElementById('network-container');
        if (container) {
            container.style.backgroundColor = backgroundColor;
        }

        // Update all nodes with new colors
        const nodes = networkData.nodes;
        const nodeUpdates = [];

        nodes.forEach(function(node) {
            const newColor = node.isMain ? colors.selected : colors[node.type] || colors.entity;
            nodeUpdates.push({
                id: node.id,
                color: newColor,
                font: {
                    size: node.isMain ? 16 : 12,
                    color: fontColor,
                    bold: node.isMain
                }
            });
        });

        // Apply node updates
        nodes.update(nodeUpdates);

        // Update edge colors
        const edges = networkData.edges;
        const edgeUpdates = [];

        edges.forEach(function(edge) {
            edgeUpdates.push({
                id: edge.id,
                font: { color: fontColor }
            });
        });

        // Apply edge updates
        edges.update(edgeUpdates);

        // Update network options
        network.setOptions({
            nodes: {
                font: { color: fontColor }
            },
            edges: {
                font: { color: fontColor }
            }
        });
    }

    // Listen for system theme changes
    if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
            // Re-detect theme when system preference changes
            setTimeout(detectAndApplyTheme, 100);
        });
    }

    // Listen for Home Assistant theme changes (if accessible)
    try {
        if (window.parent && window.parent !== window && window.parent.addEventListener) {
            window.parent.addEventListener('hass-theme-changed', function() {
                setTimeout(detectAndApplyTheme, 100);
            });
        }
    } catch (e) {
        // Ignore if we can't access parent
    }

    // Store all data for filtering
    var allData = {
        entities: [],
        automations: [],
        scripts: []
    };

    // Currently selected values
    var selectedValues = {
        entities: null,
        automations: null,
        scripts: null
    };

    // Store current JSON data for download
    var currentJsonData = null;
    var network = null;
    var networkData = null;

    function createNetworkVisualization(data) {
        var container = document.getElementById('network-container');
        var noSelectionMessage = document.getElementById('no-selection-message');
        var downloadBtn = document.getElementById('download-btn');

        if (!data || data.error) {
            noSelectionMessage.style.display = 'block';
            if (network) {
                network.destroy();
                network = null;
            }
            currentJsonData = null;
            return;
        }

        // Store the data for download
        currentJsonData = data;
        noSelectionMessage.style.display = 'none';

        var nodes = new vis.DataSet();
        var edges = new vis.DataSet();
        var nodeIds = new Set();
        var edgeId = 0;

        // Track edges to prevent duplicates
        var edgeMap = new Map();

        // Color scheme for different types (theme-aware)
        function getColors() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

            if (isDark) {
                return {
                    entity: { background: '#1565c0', border: '#64b5f6' },
                    automation: { background: '#2e7d32', border: '#81c784' },
                    script: { background: '#ef6c00', border: '#ffb74d' },
                    trigger: { background: '#c62828', border: '#f48fb1' },
                    condition: { background: '#6a1b9a', border: '#ce93d8' },
                    output: { background: '#00695c', border: '#80cbc4' },
                    selected: { background: '#f57f17', border: '#fff176' }
                };
            } else {
                return {
                    entity: { background: '#e3f2fd', border: '#2196f3' },
                    automation: { background: '#e8f5e8', border: '#4caf50' },
                    script: { background: '#fff3e0', border: '#ff9800' },
                    trigger: { background: '#ffebee', border: '#f44336' },
                    condition: { background: '#f3e5f5', border: '#9c27b0' },
                    output: { background: '#e0f2f1', border: '#009688' },
                    selected: { background: '#fff59d', border: '#ffc107' }
                };
            }
        }

        // Refresh colors for current theme
        var colors = getColors();

        function createNodeId(type, id, relationship, level) {
            // Use only type and id to ensure each item appears only once
            return `${type}_${id}`;
        }

        function addNode(type, id, label, relationship, level, isMain = false) {
            var nodeId = createNodeId(type, id, relationship, level);
            if (nodeIds.has(nodeId)) return nodeId;

            var color = isMain ? colors.selected : colors[type];
            var shape = type === 'automation' ? 'box' : type === 'script' ? 'diamond' : 'ellipse';

            // Create a display label that prioritizes friendly names
            var baseLabel = label;
            if (type === 'entity') {
                // For entities, always use friendly name if available, otherwise use ID
                baseLabel = label || id;
            }
            // For automations and scripts, use the friendly name as-is

            // Use the base label without relationship prefix
            var displayLabel = baseLabel;

            nodes.add({
                id: nodeId,
                label: displayLabel,
                color: color,
                shape: shape,
                font: { size: isMain ? 16 : 12, color: '#333', bold: isMain },
                borderWidth: isMain ? 4 : 2,
                level: level,
                type: type,
                originalId: id,
                relationship: relationship,
                isMain: isMain
            });

            nodeIds.add(nodeId);
            return nodeId;
        }

        function addEdge(fromId, toId, label, color = '#666') {
            var edgeKey = `${fromId}->${toId}`;

            if (edgeMap.has(edgeKey)) {
                // Edge already exists, add this label (allow duplicates for counting)
                var existingEdge = edgeMap.get(edgeKey);
                var existingLabels = existingEdge.labels || [];

                // Always add the label to count duplicates
                existingLabels.push(label);
                existingEdge.labels = existingLabels;

                // Create smart combined label
                var combinedLabel = createCombinedLabel(existingLabels);

                // Update existing edge
                edges.update({
                    id: existingEdge.id,
                    label: combinedLabel
                });
            } else {
                // New edge
                var newEdge = {
                    id: edgeId++,
                    from: fromId,
                    to: toId,
                    label: label,
                    color: { color: color },
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 10, color: '#666' },
                    labels: [label]
                };

                edges.add(newEdge);
                edgeMap.set(edgeKey, newEdge);
            }
        }

        function createCombinedLabel(labels) {
            if (labels.length === 1) {
                return labels[0];
            }

            // Count occurrences of each label type
            var labelCounts = {};
            labels.forEach(function(label) {
                labelCounts[label] = (labelCounts[label] || 0) + 1;
            });

            // Create combined label
            var parts = [];
            Object.keys(labelCounts).forEach(function(labelType) {
                var count = labelCounts[labelType];
                if (count > 1) {
                    parts.push(`${labelType} (${count})`);
                } else {
                    parts.push(labelType);
                }
            });

            return parts.join(', ');
        }

        // Add main node (selected item)
        // Handle double-nesting if present
        var relations = data.relations.relations || data.relations;
        var mainNodeId = addNode(
            relations.item_type,
            relations.item_id,
            relations.friendly_name,
            'main',
            0,
            true
        );

        // Process relationships recursively
        function processRelationships(items, parentNodeId, parentLevel, isUpstream) {
            if (!items || !Array.isArray(items)) return;

            items.forEach(function(item, index) {
                var level = isUpstream ? parentLevel - 1 : parentLevel + 1;
                var nodeId = addNode(
                    item.item_type,
                    item.item_id,
                    item.friendly_name,
                    item.relation_type,
                    level
                );

                // Add edge between parent and child
                if (isUpstream) {
                    // For upstream: child affects parent
                    var edgeLabel = item.relation_type;
                    var edgeColor = colors[item.relation_type]?.border || '#666';
                    addEdge(nodeId, parentNodeId, edgeLabel, edgeColor);
                } else {
                    // For downstream: parent affects child
                    var edgeLabel = item.relation_type;
                    var edgeColor = colors[item.relation_type]?.border || '#666';
                    addEdge(parentNodeId, nodeId, edgeLabel, edgeColor);
                }

                // Process nested relationships
                if (item.upstream && Array.isArray(item.upstream) && item.upstream.length > 0) {
                    processRelationships(item.upstream, nodeId, level, true);
                }
                if (item.downstream && Array.isArray(item.downstream) && item.downstream.length > 0) {
                    processRelationships(item.downstream, nodeId, level, false);
                }
            });
        }

        // Process upstream relationships
        if (relations.upstream && Array.isArray(relations.upstream)) {
            processRelationships(relations.upstream, mainNodeId, 0, true);
        }

        // Process downstream relationships
        if (relations.downstream && Array.isArray(relations.downstream)) {
            processRelationships(relations.downstream, mainNodeId, 0, false);
        }

        // Create network with theme-aware options
        networkData = { nodes: nodes, edges: edges };

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const backgroundColor = isDark ? '#1e1e1e' : '#ffffff';
        const fontColor = isDark ? '#e0e0e0' : '#333333';

        var options = {
            layout: {
                improvedLayout: true,
                clusterThreshold: 150
            },
            physics: {
                enabled: true,
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.3,
                    springLength: 95,
                    springConstant: 0.04,
                    damping: 0.09
                }
            },
            nodes: {
                font: { size: 12, color: fontColor },
                margin: 10,
                widthConstraint: { maximum: 200 }
            },
            edges: {
                smooth: {
                    enabled: true,
                    type: 'dynamic',
                    roundness: 0.5
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.8 }
                },
                font: { color: fontColor }
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true
            },
            configure: {
                enabled: false
            }
        };

        if (network) {
            network.destroy();
        }

        network = new vis.Network(container, networkData, options);

        // Set container background based on theme
        container.style.backgroundColor = backgroundColor;

        // Add click handler for nodes
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                var nodeId = params.nodes[0];
                var node = nodes.get(nodeId);

                // If it's not the main node and has the required properties, allow navigation
                if (!node.isMain && node.originalId && node.type) {
                    var apiType = node.type === 'entity' ? 'entity' : node.type;

                    // Update the appropriate dropdown
                    var dropdownType = apiType === 'entity' ? 'entities' : apiType + 's';
                    var input = document.querySelector('#' + dropdownType + '-dropdown .search-input');
                    if (input) {
                        // Find the item in allData to get the display text
                        var item = allData[dropdownType].find(function(item) {
                            return (apiType === 'entity' ? item.entity_id : item.id) === node.originalId;
                        });

                        if (item) {
                            var displayText;
                            if (apiType === 'entity') {
                                displayText = item.friendly_name && item.friendly_name !== item.entity_id
                                    ? item.friendly_name
                                    : item.entity_id;
                            } else {
                                displayText = item.alias + ' (' + item.id + ')';
                            }

                            input.value = displayText;
                            selectedValues[dropdownType] = node.originalId;

                            // Clear other selections
                            Object.keys(selectedValues).forEach(function(key) {
                                if (key !== dropdownType) {
                                    selectedValues[key] = null;
                                    var otherInput = document.querySelector('#' + key + '-dropdown .search-input');
                                    if (otherInput) otherInput.value = '';
                                }
                            });

                            // Fetch new data
                            fetchAndShowFlow(apiType, node.originalId);
                        }
                    }
                }
            }
        });

        // Fit the network to show all nodes
        setTimeout(function() {
            network.fit();
        }, 100);
    }

    function renderJsonOutput(data) {
        createNetworkVisualization(data);
    }

    function downloadJson() {
        if (!currentJsonData) return;

        var dataStr = JSON.stringify(currentJsonData, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
        var url = URL.createObjectURL(dataBlob);

        var link = document.createElement('a');
        link.href = url;

        // Generate filename based on the selected item
        var filename = 'relations';
        if (currentJsonData.relations) {
            // Handle double-nesting if present
            var relations = currentJsonData.relations.relations || currentJsonData.relations;
            if (relations.item_id) {
                filename = 'relations_' + relations.item_type + '_' + relations.item_id.replace(/[^a-zA-Z0-9]/g, '_');
            }
        }
        link.download = filename + '.json';

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }    function fetchAndShowFlow(type, id) {
      var depthInput = document.getElementById('depth-input');
      var depth = depthInput.value;

      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/api/advancedrelations/related?type=' + encodeURIComponent(type) + '&id=' + encodeURIComponent(id) + '&depth=' + encodeURIComponent(depth), true);
      xhr.withCredentials = true;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            var data = {};
            try { data = JSON.parse(xhr.responseText); } catch (e) {}
            renderJsonOutput(data);
          } else {
            renderJsonOutput({error: 'Error loading related data. Status: ' + xhr.status});
          }
        }
      };
      xhr.send();
    }

    function createSearchableDropdown(type, data) {
        var dropdown = document.getElementById(type + '-dropdown');
        var input = dropdown.querySelector('.search-input');
        var list = dropdown.querySelector('.dropdown-list');

        function filterAndRenderItems(searchTerm) {
            list.innerHTML = '';
            var filteredItems = data.filter(function(item) {
                var searchableText = '';
                if (type === 'entities') {
                    searchableText = (item.friendly_name || '') + ' ' + item.entity_id;
                } else {
                    searchableText = item.alias + ' ' + item.id;
                }
                return searchableText.toLowerCase().includes(searchTerm.toLowerCase());
            });

            if (filteredItems.length === 0) {
                var noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'No results found';
                list.appendChild(noResults);
            } else {
                filteredItems.forEach(function(item) {
                    var itemDiv = document.createElement('div');
                    itemDiv.className = 'dropdown-item';
                    if (type === 'entities') {
                        itemDiv.textContent = item.friendly_name && item.friendly_name !== item.entity_id
                            ? item.friendly_name
                            : item.entity_id;
                        itemDiv.dataset.value = item.entity_id;
                    } else {
                        itemDiv.textContent = item.alias + ' (' + item.id + ')';
                        itemDiv.dataset.value = item.id;
                    }

                    itemDiv.addEventListener('click', function() {
                        var value = itemDiv.dataset.value;
                        var displayText = itemDiv.textContent;

                        input.value = displayText;
                        selectedValues[type] = value;
                        list.style.display = 'none';

                        // Clear other selections
                        Object.keys(selectedValues).forEach(function(key) {
                            if (key !== type) {
                                selectedValues[key] = null;
                                var otherInput = document.querySelector('#' + key + '-dropdown .search-input');
                                if (otherInput) otherInput.value = '';
                            }
                        });

                        // Fetch and show flow
                        var apiType = type === 'entities' ? 'entity' : type.slice(0, -1); // Remove 's' from end
                        fetchAndShowFlow(apiType, value);
                    });

                    list.appendChild(itemDiv);
                });
            }
        }

        input.addEventListener('input', function() {
            var searchTerm = input.value;
            if (searchTerm.length > 0) {
                filterAndRenderItems(searchTerm);
                list.style.display = 'block';
            } else {
                list.style.display = 'none';
                selectedValues[type] = null;
                // Show the no selection message
                document.getElementById('json-container').style.display = 'none';
                document.getElementById('no-selection-message').style.display = 'block';
                currentJsonData = null;
            }
        });

        input.addEventListener('focus', function() {
            if (input.value.length > 0) {
                filterAndRenderItems(input.value);
                list.style.display = 'block';
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!dropdown.contains(e.target)) {
                list.style.display = 'none';
            }
        });

        // Handle keyboard navigation
        input.addEventListener('keydown', function(e) {
            var items = list.querySelectorAll('.dropdown-item');
            var selectedItem = list.querySelector('.dropdown-item.selected');
            var selectedIndex = -1;

            if (selectedItem) {
                selectedIndex = Array.from(items).indexOf(selectedItem);
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (selectedIndex < items.length - 1) {
                    if (selectedItem) selectedItem.classList.remove('selected');
                    items[selectedIndex + 1].classList.add('selected');
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedIndex > 0) {
                    if (selectedItem) selectedItem.classList.remove('selected');
                    items[selectedIndex - 1].classList.add('selected');
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.click();
                }
            } else if (e.key === 'Escape') {
                list.style.display = 'none';
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Detect and apply initial theme
      detectAndApplyTheme();

      // Add theme toggle button event listener
      document.getElementById('theme-toggle-btn').addEventListener('click', toggleTheme);

      // Add download button event listener
      document.getElementById('download-btn').addEventListener('click', downloadJson);

      // Add network control event listeners
      document.getElementById('fit-btn').addEventListener('click', function() {
        if (network) {
          network.fit();
        }
      });

      document.getElementById('reset-zoom-btn').addEventListener('click', function() {
        if (network) {
          network.moveTo({scale: 1.0});
        }
      });

      // Add layout toggle functionality
      var isHierarchical = false;
      document.getElementById('layout-toggle-btn').addEventListener('click', function() {
        if (!network || !networkData) return;

        isHierarchical = !isHierarchical;
        var options;

        if (isHierarchical) {
          // Hierarchical layout
          options = {
            layout: {
              hierarchical: {
                enabled: true,
                direction: 'UD',
                sortMethod: 'directed',
                nodeSpacing: 200,
                levelSeparation: 150
              }
            },
            physics: {
              enabled: false
            }
          };
          this.textContent = 'Force Layout';
        } else {
          // Force-directed layout
          options = {
            layout: {
              improvedLayout: true,
              clusterThreshold: 150
            },
            physics: {
              enabled: true,
              stabilization: { iterations: 100 },
              barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.3,
                springLength: 95,
                springConstant: 0.04,
                damping: 0.09
              }
            }
          };
          this.textContent = 'Hierarchical Layout';
        }

        network.setOptions(options);
        network.fit();
      });      // Add depth change event listener
      document.getElementById('depth-input').addEventListener('input', function() {
        var depthValue = parseInt(this.value);
        var warningDiv = document.getElementById('depth-warning');

        // Show warning for high depth values
        if (depthValue > 10 || depthValue === 0) {
          warningDiv.style.display = 'block';
          if (depthValue === 0) {
            warningDiv.textContent = 'Warning: Infinite depth may significantly slow down the analysis.';
          } else {
            warningDiv.textContent = 'Warning: High depth values may significantly slow down the analysis.';
          }
        } else {
          warningDiv.style.display = 'none';
        }

        // Re-fetch data if something is currently selected
        var currentSelection = null;
        var currentType = null;

        Object.keys(selectedValues).forEach(function(type) {
          if (selectedValues[type]) {
            currentSelection = selectedValues[type];
            currentType = type === 'entities' ? 'entity' : type.slice(0, -1); // Remove 's' from end
          }
        });

        if (currentSelection && currentType) {
          fetchAndShowFlow(currentType, currentSelection);
        }
      });

      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/api/advancedrelations/data', true);
      xhr.withCredentials = true;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            var data = {};
            try { data = JSON.parse(xhr.responseText); } catch (e) {}

            // Store all data
            allData.entities = Array.isArray(data.entities) ? data.entities : [];
            allData.automations = Array.isArray(data.automations) ? data.automations : [];
            allData.scripts = Array.isArray(data.scripts) ? data.scripts : [];

            // Create searchable dropdowns
            createSearchableDropdown('entities', allData.entities);
            createSearchableDropdown('automations', allData.automations);
            createSearchableDropdown('scripts', allData.scripts);
          } else {
            console.error('Data fetch error:', xhr.status, xhr.statusText);
          }
        }
      };
      xhr.send();
    });
    </script>
</body>
</html>
