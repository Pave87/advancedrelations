<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Relations Visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 2em; }
        h1 { color: #2196f3; }
        #visualization {
            border: 1px solid #ccc;
            margin-top: 2em;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 500px);
            min-height: 300px;
        }
        #network-container {
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #controls button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 5px;
        }
        #controls button:hover {
            background: #1976d2;
        }
        .section { margin-bottom: 2em; }
        .label { font-weight: bold; }

        /* Searchable dropdown styles */
        .searchable-dropdown {
            position: relative;
            min-width: 300px;
            margin-top: 0.5em;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .search-input:focus {
            border-color: #2196f3;
            outline: none;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .dropdown-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .dropdown-item:hover {
            background-color: #f5f5f5;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item.selected {
            background-color: #e3f2fd;
        }

        .no-results {
            padding: 8px 12px;
            color: #666;
            font-style: italic;
        }

        /* Legend styles */
        .legend {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-top: 1em;
            font-size: 12px;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            color: #333;
        }
        .legend-section {
            margin-bottom: 10px;
        }
        .legend-section:last-child {
            margin-bottom: 0;
        }
        .legend-section-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .legend-shape {
            width: 16px;
            height: 16px;
            border: 2px solid;
            display: inline-block;
            text-align: center;
            line-height: 12px;
            font-size: 10px;
            font-weight: bold;
        }
        .legend-shape.ellipse {
            border-radius: 50%;
        }
        .legend-shape.box {
            border-radius: 2px;
        }
        .legend-shape.diamond {
            transform: rotate(45deg);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>Advanced Relations Visualization</h1>
    <div class="section">
        <span class="label">Entities:</span><br>
        <div class="searchable-dropdown" id="entities-dropdown">
            <input type="text" class="search-input" placeholder="Search entities..." data-type="entities">
            <div class="dropdown-list"></div>
        </div>
    </div>
    <div class="section">
        <span class="label">Automations:</span><br>
        <div class="searchable-dropdown" id="automations-dropdown">
            <input type="text" class="search-input" placeholder="Search automations..." data-type="automations">
            <div class="dropdown-list"></div>
        </div>
    </div>
    <div class="section">
        <span class="label">Scripts:</span><br>
        <div class="searchable-dropdown" id="scripts-dropdown">
            <input type="text" class="search-input" placeholder="Search scripts..." data-type="scripts">
            <div class="dropdown-list"></div>
        </div>
    </div>
    <div class="section">
        <span class="label">Recursion Depth:</span><br>
        <div style="display: flex; gap: 2em; align-items: flex-start; margin-top: 0.5em;">
            <div style="flex-shrink: 0;">
                <input type="number" id="depth-input" value="3" min="0" step="1" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; width: 100px;">
                <div style="font-size: 12px; color: #666; margin-top: 4px; width: 250px;">
                    Enter depth (0 = infinite, higher values show more indirect relationships but may take longer).
                </div>
                <div id="depth-warning" style="font-size: 12px; color: #ff9800; margin-top: 4px; display: none; width: 250px;">
                    Warning: High depth values may significantly slow down the analysis.
                </div>
            </div>
            <div class="legend" style="flex: 1; margin-top: 0;">
                <div class="legend-title">Legend</div>
                <div class="legend-items" style="gap: 20px;">
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #e3f2fd; border-color: #2196f3;"></div>
                        <span>Entity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape box" style="background: #e8f5e8; border-color: #4caf50;"></div>
                        <span>Automation</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape diamond" style="background: #fff3e0; border-color: #ff9800;"></div>
                        <span>Script</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #fff59d; border-color: #ffc107;"></div>
                        <span>Selected</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #ffebee; border-color: #f44336;"></div>
                        <span>Trigger</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #f3e5f5; border-color: #9c27b0;"></div>
                        <span>Condition</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape ellipse" style="background: #e0f2f1; border-color: #009688;"></div>
                        <span>Output</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="visualization">
        <div id="controls">
            <button id="download-btn">Download JSON</button>
            <button id="fit-btn">Fit View</button>
            <button id="reset-zoom-btn">Reset Zoom</button>
            <button id="layout-toggle-btn">Hierarchical Layout</button>
        </div>
        <div id="network-container"></div>
        <div id="no-selection-message" style="padding: 40px; text-align: center; color: #666; font-size: 16px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            Select an entity, automation, or script above to view its relationships.
        </div>
    </div>
    <script>
    // Store all data for filtering
    var allData = {
        entities: [],
        automations: [],
        scripts: []
    };

    // Currently selected values
    var selectedValues = {
        entities: null,
        automations: null,
        scripts: null
    };

    // Store current JSON data for download
    var currentJsonData = null;
    var network = null;
    var networkData = null;

    function createNetworkVisualization(data) {
        var container = document.getElementById('network-container');
        var noSelectionMessage = document.getElementById('no-selection-message');
        var downloadBtn = document.getElementById('download-btn');

        if (!data || data.error) {
            noSelectionMessage.style.display = 'block';
            if (network) {
                network.destroy();
                network = null;
            }
            currentJsonData = null;
            return;
        }

        // Store the data for download
        currentJsonData = data;
        noSelectionMessage.style.display = 'none';

        var nodes = new vis.DataSet();
        var edges = new vis.DataSet();
        var nodeIds = new Set();
        var edgeId = 0;

        // Track edges to prevent duplicates
        var edgeMap = new Map();

        // Color scheme for different types
        var colors = {
            entity: { background: '#e3f2fd', border: '#2196f3' },
            automation: { background: '#e8f5e8', border: '#4caf50' },
            script: { background: '#fff3e0', border: '#ff9800' },
            trigger: { background: '#ffebee', border: '#f44336' },
            condition: { background: '#f3e5f5', border: '#9c27b0' },
            output: { background: '#e0f2f1', border: '#009688' },
            selected: { background: '#fff59d', border: '#ffc107' }
        };

        function createNodeId(type, id, relationship, level) {
            // Use only type and id to ensure each item appears only once
            return `${type}_${id}`;
        }

        function addNode(type, id, label, relationship, level, isMain = false) {
            var nodeId = createNodeId(type, id, relationship, level);
            if (nodeIds.has(nodeId)) return nodeId;

            var color = isMain ? colors.selected : colors[type];
            var shape = type === 'automation' ? 'box' : type === 'script' ? 'diamond' : 'ellipse';

            // Create a display label that prioritizes friendly names
            var baseLabel = label;
            if (type === 'entity') {
                // For entities, always use friendly name if available, otherwise use ID
                baseLabel = label || id;
            }
            // For automations and scripts, use the friendly name as-is

            // Use the base label without relationship prefix
            var displayLabel = baseLabel;

            nodes.add({
                id: nodeId,
                label: displayLabel,
                color: color,
                shape: shape,
                font: { size: isMain ? 16 : 12, color: '#333', bold: isMain },
                borderWidth: isMain ? 4 : 2,
                level: level,
                type: type,
                originalId: id,
                relationship: relationship,
                isMain: isMain
            });

            nodeIds.add(nodeId);
            return nodeId;
        }

        function addEdge(fromId, toId, label, color = '#666') {
            var edgeKey = `${fromId}->${toId}`;

            if (edgeMap.has(edgeKey)) {
                // Edge already exists, add this label (allow duplicates for counting)
                var existingEdge = edgeMap.get(edgeKey);
                var existingLabels = existingEdge.labels || [];

                // Always add the label to count duplicates
                existingLabels.push(label);
                existingEdge.labels = existingLabels;

                // Create smart combined label
                var combinedLabel = createCombinedLabel(existingLabels);

                // Update existing edge
                edges.update({
                    id: existingEdge.id,
                    label: combinedLabel
                });
            } else {
                // New edge
                var newEdge = {
                    id: edgeId++,
                    from: fromId,
                    to: toId,
                    label: label,
                    color: { color: color },
                    arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                    font: { size: 10, color: '#666' },
                    labels: [label]
                };

                edges.add(newEdge);
                edgeMap.set(edgeKey, newEdge);
            }
        }

        function createCombinedLabel(labels) {
            if (labels.length === 1) {
                return labels[0];
            }

            // Count occurrences of each label type
            var labelCounts = {};
            labels.forEach(function(label) {
                labelCounts[label] = (labelCounts[label] || 0) + 1;
            });

            // Create combined label
            var parts = [];
            Object.keys(labelCounts).forEach(function(labelType) {
                var count = labelCounts[labelType];
                if (count > 1) {
                    parts.push(`${labelType} (${count})`);
                } else {
                    parts.push(labelType);
                }
            });

            return parts.join(', ');
        }

        // Add main node (selected item)
        // Handle double-nesting if present
        var relations = data.relations.relations || data.relations;
        var mainNodeId = addNode(
            relations.item_type,
            relations.item_id,
            relations.friendly_name,
            'main',
            0,
            true
        );

        // Process relationships recursively
        function processRelationships(items, parentNodeId, parentLevel, isUpstream) {
            if (!items || !Array.isArray(items)) return;

            items.forEach(function(item, index) {
                var level = isUpstream ? parentLevel - 1 : parentLevel + 1;
                var nodeId = addNode(
                    item.item_type,
                    item.item_id,
                    item.friendly_name,
                    item.relation_type,
                    level
                );

                // Add edge between parent and child
                if (isUpstream) {
                    // For upstream: child affects parent
                    var edgeLabel = item.relation_type;
                    var edgeColor = colors[item.relation_type]?.border || '#666';
                    addEdge(nodeId, parentNodeId, edgeLabel, edgeColor);
                } else {
                    // For downstream: parent affects child
                    var edgeLabel = item.relation_type;
                    var edgeColor = colors[item.relation_type]?.border || '#666';
                    addEdge(parentNodeId, nodeId, edgeLabel, edgeColor);
                }

                // Process nested relationships
                if (item.upstream && Array.isArray(item.upstream) && item.upstream.length > 0) {
                    processRelationships(item.upstream, nodeId, level, true);
                }
                if (item.downstream && Array.isArray(item.downstream) && item.downstream.length > 0) {
                    processRelationships(item.downstream, nodeId, level, false);
                }
            });
        }

        // Process upstream relationships
        if (relations.upstream && Array.isArray(relations.upstream)) {
            processRelationships(relations.upstream, mainNodeId, 0, true);
        }

        // Process downstream relationships
        if (relations.downstream && Array.isArray(relations.downstream)) {
            processRelationships(relations.downstream, mainNodeId, 0, false);
        }

        // Create network
        networkData = { nodes: nodes, edges: edges };

        var options = {
            layout: {
                improvedLayout: true,
                clusterThreshold: 150
            },
            physics: {
                enabled: true,
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.3,
                    springLength: 95,
                    springConstant: 0.04,
                    damping: 0.09
                }
            },
            nodes: {
                font: { size: 12 },
                margin: 10,
                widthConstraint: { maximum: 200 }
            },
            edges: {
                smooth: {
                    enabled: true,
                    type: 'dynamic',
                    roundness: 0.5
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.8 }
                }
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true
            }
        };

        if (network) {
            network.destroy();
        }

        network = new vis.Network(container, networkData, options);

        // Add click handler for nodes
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                var nodeId = params.nodes[0];
                var node = nodes.get(nodeId);

                // If it's not the main node and has the required properties, allow navigation
                if (!node.isMain && node.originalId && node.type) {
                    var apiType = node.type === 'entity' ? 'entity' : node.type;

                    // Update the appropriate dropdown
                    var dropdownType = apiType === 'entity' ? 'entities' : apiType + 's';
                    var input = document.querySelector('#' + dropdownType + '-dropdown .search-input');
                    if (input) {
                        // Find the item in allData to get the display text
                        var item = allData[dropdownType].find(function(item) {
                            return (apiType === 'entity' ? item.entity_id : item.id) === node.originalId;
                        });

                        if (item) {
                            var displayText;
                            if (apiType === 'entity') {
                                displayText = item.friendly_name && item.friendly_name !== item.entity_id
                                    ? item.friendly_name
                                    : item.entity_id;
                            } else {
                                displayText = item.alias + ' (' + item.id + ')';
                            }

                            input.value = displayText;
                            selectedValues[dropdownType] = node.originalId;

                            // Clear other selections
                            Object.keys(selectedValues).forEach(function(key) {
                                if (key !== dropdownType) {
                                    selectedValues[key] = null;
                                    var otherInput = document.querySelector('#' + key + '-dropdown .search-input');
                                    if (otherInput) otherInput.value = '';
                                }
                            });

                            // Fetch new data
                            fetchAndShowFlow(apiType, node.originalId);
                        }
                    }
                }
            }
        });

        // Fit the network to show all nodes
        setTimeout(function() {
            network.fit();
        }, 100);
    }

    function renderJsonOutput(data) {
        createNetworkVisualization(data);
    }

    function downloadJson() {
        if (!currentJsonData) return;

        var dataStr = JSON.stringify(currentJsonData, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
        var url = URL.createObjectURL(dataBlob);

        var link = document.createElement('a');
        link.href = url;

        // Generate filename based on the selected item
        var filename = 'relations';
        if (currentJsonData.relations) {
            // Handle double-nesting if present
            var relations = currentJsonData.relations.relations || currentJsonData.relations;
            if (relations.item_id) {
                filename = 'relations_' + relations.item_type + '_' + relations.item_id.replace(/[^a-zA-Z0-9]/g, '_');
            }
        }
        link.download = filename + '.json';

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }    function fetchAndShowFlow(type, id) {
      var depthInput = document.getElementById('depth-input');
      var depth = depthInput.value;

      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/api/advancedrelations/related?type=' + encodeURIComponent(type) + '&id=' + encodeURIComponent(id) + '&depth=' + encodeURIComponent(depth), true);
      xhr.withCredentials = true;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            var data = {};
            try { data = JSON.parse(xhr.responseText); } catch (e) {}
            renderJsonOutput(data);
          } else {
            renderJsonOutput({error: 'Error loading related data. Status: ' + xhr.status});
          }
        }
      };
      xhr.send();
    }

    function createSearchableDropdown(type, data) {
        var dropdown = document.getElementById(type + '-dropdown');
        var input = dropdown.querySelector('.search-input');
        var list = dropdown.querySelector('.dropdown-list');

        function filterAndRenderItems(searchTerm) {
            list.innerHTML = '';
            var filteredItems = data.filter(function(item) {
                var searchableText = '';
                if (type === 'entities') {
                    searchableText = (item.friendly_name || '') + ' ' + item.entity_id;
                } else {
                    searchableText = item.alias + ' ' + item.id;
                }
                return searchableText.toLowerCase().includes(searchTerm.toLowerCase());
            });

            if (filteredItems.length === 0) {
                var noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'No results found';
                list.appendChild(noResults);
            } else {
                filteredItems.forEach(function(item) {
                    var itemDiv = document.createElement('div');
                    itemDiv.className = 'dropdown-item';
                    if (type === 'entities') {
                        itemDiv.textContent = item.friendly_name && item.friendly_name !== item.entity_id
                            ? item.friendly_name
                            : item.entity_id;
                        itemDiv.dataset.value = item.entity_id;
                    } else {
                        itemDiv.textContent = item.alias + ' (' + item.id + ')';
                        itemDiv.dataset.value = item.id;
                    }

                    itemDiv.addEventListener('click', function() {
                        var value = itemDiv.dataset.value;
                        var displayText = itemDiv.textContent;

                        input.value = displayText;
                        selectedValues[type] = value;
                        list.style.display = 'none';

                        // Clear other selections
                        Object.keys(selectedValues).forEach(function(key) {
                            if (key !== type) {
                                selectedValues[key] = null;
                                var otherInput = document.querySelector('#' + key + '-dropdown .search-input');
                                if (otherInput) otherInput.value = '';
                            }
                        });

                        // Fetch and show flow
                        var apiType = type === 'entities' ? 'entity' : type.slice(0, -1); // Remove 's' from end
                        fetchAndShowFlow(apiType, value);
                    });

                    list.appendChild(itemDiv);
                });
            }
        }

        input.addEventListener('input', function() {
            var searchTerm = input.value;
            if (searchTerm.length > 0) {
                filterAndRenderItems(searchTerm);
                list.style.display = 'block';
            } else {
                list.style.display = 'none';
                selectedValues[type] = null;
                // Show the no selection message
                document.getElementById('json-container').style.display = 'none';
                document.getElementById('no-selection-message').style.display = 'block';
                currentJsonData = null;
            }
        });

        input.addEventListener('focus', function() {
            if (input.value.length > 0) {
                filterAndRenderItems(input.value);
                list.style.display = 'block';
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!dropdown.contains(e.target)) {
                list.style.display = 'none';
            }
        });

        // Handle keyboard navigation
        input.addEventListener('keydown', function(e) {
            var items = list.querySelectorAll('.dropdown-item');
            var selectedItem = list.querySelector('.dropdown-item.selected');
            var selectedIndex = -1;

            if (selectedItem) {
                selectedIndex = Array.from(items).indexOf(selectedItem);
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (selectedIndex < items.length - 1) {
                    if (selectedItem) selectedItem.classList.remove('selected');
                    items[selectedIndex + 1].classList.add('selected');
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedIndex > 0) {
                    if (selectedItem) selectedItem.classList.remove('selected');
                    items[selectedIndex - 1].classList.add('selected');
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedItem) {
                    selectedItem.click();
                }
            } else if (e.key === 'Escape') {
                list.style.display = 'none';
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Add download button event listener
      document.getElementById('download-btn').addEventListener('click', downloadJson);

      // Add network control event listeners
      document.getElementById('fit-btn').addEventListener('click', function() {
        if (network) {
          network.fit();
        }
      });

      document.getElementById('reset-zoom-btn').addEventListener('click', function() {
        if (network) {
          network.moveTo({scale: 1.0});
        }
      });

      // Add layout toggle functionality
      var isHierarchical = false;
      document.getElementById('layout-toggle-btn').addEventListener('click', function() {
        if (!network || !networkData) return;

        isHierarchical = !isHierarchical;
        var options;

        if (isHierarchical) {
          // Hierarchical layout
          options = {
            layout: {
              hierarchical: {
                enabled: true,
                direction: 'UD',
                sortMethod: 'directed',
                nodeSpacing: 200,
                levelSeparation: 150
              }
            },
            physics: {
              enabled: false
            }
          };
          this.textContent = 'Force Layout';
        } else {
          // Force-directed layout
          options = {
            layout: {
              improvedLayout: true,
              clusterThreshold: 150
            },
            physics: {
              enabled: true,
              stabilization: { iterations: 100 },
              barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.3,
                springLength: 95,
                springConstant: 0.04,
                damping: 0.09
              }
            }
          };
          this.textContent = 'Hierarchical Layout';
        }

        network.setOptions(options);
        network.fit();
      });      // Add depth change event listener
      document.getElementById('depth-input').addEventListener('input', function() {
        var depthValue = parseInt(this.value);
        var warningDiv = document.getElementById('depth-warning');

        // Show warning for high depth values
        if (depthValue > 10 || depthValue === 0) {
          warningDiv.style.display = 'block';
          if (depthValue === 0) {
            warningDiv.textContent = 'Warning: Infinite depth may significantly slow down the analysis.';
          } else {
            warningDiv.textContent = 'Warning: High depth values may significantly slow down the analysis.';
          }
        } else {
          warningDiv.style.display = 'none';
        }

        // Re-fetch data if something is currently selected
        var currentSelection = null;
        var currentType = null;

        Object.keys(selectedValues).forEach(function(type) {
          if (selectedValues[type]) {
            currentSelection = selectedValues[type];
            currentType = type === 'entities' ? 'entity' : type.slice(0, -1); // Remove 's' from end
          }
        });

        if (currentSelection && currentType) {
          fetchAndShowFlow(currentType, currentSelection);
        }
      });

      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/api/advancedrelations/data', true);
      xhr.withCredentials = true;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            var data = {};
            try { data = JSON.parse(xhr.responseText); } catch (e) {}

            // Store all data
            allData.entities = Array.isArray(data.entities) ? data.entities : [];
            allData.automations = Array.isArray(data.automations) ? data.automations : [];
            allData.scripts = Array.isArray(data.scripts) ? data.scripts : [];

            // Create searchable dropdowns
            createSearchableDropdown('entities', allData.entities);
            createSearchableDropdown('automations', allData.automations);
            createSearchableDropdown('scripts', allData.scripts);
          } else {
            console.error('Data fetch error:', xhr.status, xhr.statusText);
          }
        }
      };
      xhr.send();
    });
    </script>
</body>
</html>
